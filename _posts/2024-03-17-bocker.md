---
title: "Bocker - Docker implemented in around 100 lines of bash"
tags: [docker, wip]
---


<!--more-->

> 修订历史
> - 2024.03.17 创建笔记

> All thanks to ChatGPT 

## 背景知识


## 脚本解释
### main
```
set -o errexit: 该选项也可以使用 set -e 来表示。它启用了 Bash 的 "errexit" 特性，意味着一旦任何命令返回非零的退出状态（表示命令执行失败），则立即退出脚本。这有助于确保脚本在发生错误时能够及时停止执行。

set -o nounset: 该选项也可以使用 set -u 来表示。它启用了 Bash 的 "nounset" 特性，意味着如果尝试使用未设置的变量，则会产生一个错误并停止脚本的执行。这有助于避免在使用未初始化变量时出现意外行为。

set -o pipefail: 该选项启用了 Bash 的 "pipefail" 特性，它会在管道命令序列中的任何命令返回非零的退出状态时，将整个管道的退出状态设置为非零。默认情况下，如果管道中的最后一个命令返回非零退出状态，那么整个管道的退出状态将被视为非零，但前面的命令的退出状态会被忽略。通过启用 "pipefail"，可以更好地捕获管道中任何命令的失败状态。

shopt -s nullglob: shopt 是 Bash 的内置命令，用于设置 shell 的选项和属性。-s nullglob 表示启用 nullglob 选项。当这个选项被启用时，如果通配符模式没有匹配到任何文件时，它将会展开为空而不是原样返回。这可以避免出现不必要的错误，例如在使用 for 循环迭代文件时，如果没有匹配到任何文件，循环将不会执行

btrfs_path='/var/bocker'：这行代码将字符串 '/var/bocker' 赋值给变量 btrfs_path，用于存储 Btrfs 文件系统的路径。

cgroups='cpu,cpuacct,memory'：这行代码将字符串 'cpu,cpuacct,memory' 赋值给变量 cgroups，用于存储 cgroups 的名称。

[[ $# -gt 0 ]]：这是一个条件判断语句，判断脚本的命令行参数数量是否大于 0。$# 是一个特殊变量，表示命令行参数的数量。

while [ "${1:0:2}" == '--' ]; do：这是一个 while 循环语句，它的条件是判断命令行参数是否以两个连字符开头。${1:0:2} 表示取命令行参数的前两个字符。

OPTION=${1:2}：这行代码将命令行参数的前两个字符（去除连字符）赋值给变量 OPTION。

[[ $OPTION =~ = ]]：这是一个条件判断语句，判断变量 OPTION 是否包含等号（=）。

declare "BOCKER_${OPTION/=*/}=${OPTION/*=/}"：这行代码根据等号的存在与否，将命令行参数的键值对转换为变量声明。例如，如果命令行参数为 --foo=bar，那么这行代码将声明一个名为 BOCKER_foo 的变量，并将其值设置为 bar。

declare "BOCKER_${OPTION}=x"：这行代码处理没有等号的命令行参数，它将命令行参数作为变量名，并将其值设置为 x。

shift：这行代码将命令行参数向左移动一位，丢弃第一个参数，使得下一个参数成为新的 $1。

[[ -z "${1-}" ]]：这是一个条件判断语句，它检查变量 $1 是否为空。-z 是一个条件判断运算符，用于检查字符串是否为空。

"${1-}"：这是一种变量替换语法，${1-} 表示如果变量 $1 未设置或为空，则将其替换为空字符串。

&&：这是一个逻辑运算符，表示当前面的条件为真时，才执行后面的命令。

bocker_help "$0"：这行代码调用名为 bocker_help 的函数，并传递脚本的名称 ($0) 作为参数。$0 是一个特殊变量，表示脚本本身的名称。

case $1 in：这是 case 语句的开头，表示要对变量 $1 的不同值进行匹配。

pull|init|rm|images|ps|run|exec|logs|commit)：这是第一个匹配模式，它列出了多个值，用竖线 | 分隔。如果 $1 的值匹配其中任意一个值，就会执行对应的操作。

bocker_"$1" "${@:2}"：这行代码是一个命令，根据匹配到的值执行相应的操作。bocker_"$1" 构造了一个函数名，使用匹配到的值作为函数名的一部分，然后通过 ${@:2} 传递剩余的命令行参数给该函数。

*) bocker_help "$0" ;;：这是 case 语句的默认匹配模式，表示如果 $1 的值不匹配前面列出的任何值，就会执行这个默认操作。它调用 bocker_help 函数，并将脚本的名称 $0 作为参数传递给它。

esac：这是 case 语句的结束标记。
```
### help
```
function bocker_help() {：这行代码定义了一个名为 bocker_help 的函数。

#HELP Display this message:\nBOCKER help：这是一个注释，以 #HELP 开头，用于指示帮助信息的内容。\n 表示换行符。

sed -n "s/^.*#HELP\\s//p;" < "$1"：这行代码使用 sed 命令从文件 $1 中提取以 #HELP 开头的行，并将其内容作为输出。-n 选项表示只输出匹配的行，s/^.*#HELP\\s//p 是一个正则表达式，用于匹配以 #HELP 开头的行，并去除 #HELP 后的空格。

sed "s/\\\\n/\n\t/g;s/$/\n/;s!BOCKER!${1/!/\\!}!g"：这行代码使用 sed 命令对输出的文本进行替换和处理。

s/\\\\n/\n\t/g：这个替换表达式用于将字符串中的 \\n 替换为换行符和制表符，以便格式化显示帮助信息。\\\\n 是用于表示转义的字符串 \n。

s/$/\n/：这个替换表达式用于在文本的末尾添加一个换行符，以确保最后一行也能正常显示。

s!BOCKER!${1/!/\\!}!g：这个替换表达式用于将字符串中的 BOCKER 替换为函数的第一个参数，并对参数进行转义处理。${1/!/\\!} 是一个替换操作，用于将参数中的 ! 替换为转义后的 \\!，以避免 sed 命令解析时出现问题。
```

### check
```
btrfs subvolume list "$btrfs_path"：这部分代码执行了一个 btrfs 命令，使用 subvolume list 参数来列出指定路径 $btrfs_path 下的子卷信息。$btrfs_path 是一个变量，表示 btrfs 文件系统的路径。

|：这是管道符号，将上一个命令的输出作为下一个命令的输入。

grep -qw "$1"：这部分代码使用 grep 命令来搜索前一个命令的输出，查找是否存在与 $1 相匹配的行。$1 是脚本的第一个命令行参数。

-q 选项表示静默模式，不输出任何匹配结果。
-w 选项表示只匹配整个单词，不匹配部分单词。
&& echo 0：这是一个条件判断，如果前一个命令（grep）成功匹配到了结果，则执行 echo 0 输出 0。

|| echo 1：这也是一个条件判断，如果前一个命令（grep）没有匹配到结果，则执行 echo 1 输出 1。
```



