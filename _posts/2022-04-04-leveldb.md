---
title: "LevelDB源码分析"
tags: [database, code]
---

最近我摸索出了一种比较好的，给技术书籍做笔记的方法，并从中受益匪浅。自然而然，我也开始思考如何为源代码做阅读笔记，尝试找到一种适合自己的记录方法。

简化源码、时序、设计图？挑重点、细致？代码实现方法？

<!--more-->

## 简介
LevelDB不是SQL数据库，没有关系模型，不支持SQL语句，不支持索引。不能多个进程同时访问数据库，同一个进程的多个线程可以同时操作。

## Key
**user_key** 用户输入的key

**InternalKey** 数据库内部使用的Key，格式`user_key SequenceNum Type`

**LookupKey** 格式`InternalKeyLength InternalKey`

## 迭代器
**Iterator** 抽象类。允许注册清理函数`RegisterCleanup`，可以注册多个，在迭代器析构时调用。

**IteratorWrapper** 持有`Iterator* iter_`。提供和`Iterator`同样的接口，将调用转发给`iter_`。记录`iter_`的`key`和`value`，避免多次调用虚函数。

**TwoLevelIterator** `Iterator`的派生类，二级迭代器。持有指向第一层的`IteratorWrapper index_iter_`，由构造函数初始化，和指向第二层的`IteratorWrapper data_iter_`。迭代器操作都是在`data_iter_`上。

构造时会传入一个返回`Iterator*`的函数指针`BlockFunction`，用来获得`index_iter_`的`value`指向对应容器的第二层迭代器`data_iter_`。当`index_iter_`更新，会调用`BlockFunction`获得新的`data_iter_`

## MemTable
**Arena** 一个简单的内存池。其中类成员`char* alloc_ptr_`指向当前空闲内存地址，`size_t alloc_bytes_remaining_`记录当前块剩余容量，`vector<char*> blocks_`，保存所有内存块的地址。

提供`char* Allocate(size_t bytes)`的接口。当`bytes`小于`alloc_bytes_remaining_`，返回`alloc_ptr_`。否则`new`新的`char`数组，新数组大小为4K或`bytes`(当`bytes`>1K)，`alloc_ptr_`指向新地址。注意，旧内存块剩余的空间会浪费掉。

也提供对齐`Allocate`的接口，实现方式同上

**SkipList** 使用原子操作和模板技术实现跳表。不支持删除，不能插入重复值。使用Arena来分配新节点的内存。后趋节点数组使用柔性数组实现。上一层节点数是下一层的1/4。

> 未实现del操作是因为元素删除也是插入，删除某个Key的Value在 Memtable 内是作为插入一条记录实施的，但是会打上一个 Key 的删除标记，真正的删除操作是Lazy的，会在以后的 Compaction 过程中去掉这个KV。


**MemTable** 持有Arena和SkipList。引用计数，没有被引用时`delete this`。跳表节点格式为`LookupKey ValueLength Value`

**MemTableIterator**  `Iterator`的派生类，对`SkipList::Iterator`进行封装

## Log
每32K为一个`Block`，`Block`由`Record`组成。格式如下：
```
Block := Record *
Record := Header Content
Header := Checksum Length Type
Type := kFullType | kFirstType | kMiddleType | kLastType
```
`Type`用来表明当前`Record`中的数据与要写入数据的关系。

**Writer** 提供`AddRecord`接口，将数据按照上述格式写入文件，文件在构造时指定

**Reader** 提供`ReadRecord`接口，按照上述格式读出文件的数据，文件在构造时指定

## SSTable


## Cache
**Cache** 抽象类。

**Cache::Handle** `Insert`等操作返回的句柄

**LRUHandle** `HandleTable`和`LRUCache`的节点，拥有前驱后趋指针。使用柔性数组存放`key`。没继承`Cache::Handle`?

**HandleTable** 使用拉链法的哈希表，节点是`LRUHandle`

**LRUCache** 持有`HandleTable`来快速查找`LRUHandle`节点，以及两个`LRUHandle`链表` lru_`、`in_use_`。被引用到的节点放在`in_use_`中，当没被引用则转移到`lru_`。

` lru_`链表采用LRU算法进行管理。如果达到上限，则调用最久未使用节点的`deleter`，并释放空间，这个`deleter`在插入该节点时定义。

**ShardedLRUCache** `Cache`的派生类，持有`LRUCache`数组，对`key`进行哈希分区到数组中。接口对`LRUCache`进行简单封装。

## 版本控制
**FileMetaData** `SSTable`文件的元信息，包括文件大小，文件编号，最大最小`InternalKey`，引用计数（被不同`Version`引用）

**Version** 记录当前版本所有文件的信息`vector<FileMetaData*> files_[config::kNumLevels]`。作为`VersionSet`的节点，拥有前驱和后趋的节点指针。析构会修改前驱和后趋指针、减少`files_`中文件的引用，如果引用为零则`delete`

**Version::LevelFileNumIterator** `Iterator`的派生类，是`Version::files_`中某一层的迭代器。`key()`返回指向`FileMetaData`的最大`InternalKey`，`value()`返回该`FileMetaData`的文件编号和文件大小，

**TableCache** 持有`ShardedLRUCache`，缓存SSTable文件。`ShardedLRUCache`的节点以文件编号为`key`，`{RandomAccessFile*, Table*}*`为`value`，`deleter`是清理`value`中成员申请的内存

**VersionSet**

**VersionEdit** 保存相邻两个`Version`的差异（比如`vector<pair<int, FileMetaData>> new_files_`用来记录新增了哪些文件），并提供序列化反序列化`VersionEdit`的接口


## 其他
**WriteBatch** 将所有的操作记录到`rep_`，然后再通过`WriteBatch::Iterate(Handler* handler)`一起提交
```
WriteBatch::rep_ :=
   sequence: fixed64
   count: fixed32
   data: record[count]
record :=
   kTypeValue varstring varstring         |
   kTypeDeletion varstring
varstring :=
   len: varint32
   data: uint8[len]
```
其中`WriteBatch`、`WriteBatchInternal`、`Handler`三者的关系可以学习一下
```
// include/leveldb/write_batch.h 暴露给用户的api
class WriteBatch {
 public:
  class Handler {
   public:
    virtual void Put(const Slice& key, const Slice& value) = 0;
    ...
  };
  Status Iterate(Handler* handler) const; // 将rep_中的数据通过handler提交出去
  ...
 private:
  friend class WriteBatchInternal;
};

// db/write_batch_internal.h 暴露给内部使用的api
class WriteBatchInternal {
 public:
   static Status InsertInto(const WriteBatch* batch, MemTable* memtable);
   ...
}；

// db/write_batch.cc 
namespace {
// 提交给MemTable的hander，同时会维护序列号，每次提交递增
class MemTableInserter : public WriteBatch::Handler {  ...  };
}  
Status WriteBatchInternal::InsertInto(const WriteBatch* b, MemTable* memtable) {
  MemTableInserter inserter;
  ...
  return b->Iterate(&inserter);
}
```


**Varint32/64** 对于数值小的数字，不需要4bytes、8bytes，会浪费空间。使用变长的表示方法，每7bit代表一个数，第8bit代表是否还有下一个字节。

**SnapshotList** 维护双向链表，节点的值是`SequenceNumber`。链表支持向末尾加入节点，以及删除任意节点。


## TODO
- [ ] 使用raw指针和引用计数方法，要很注意对象的所有权、生命期。
- [ ] 每个模块暴露哪些内容，其他内容如何封装。
- [ ] 考虑每个模块是如何发展到如今样子的，能否给之后自己的编码提供指导。
- [ ] 测试的书写方法
- [ ] 如何实现线程安全，理清其中加锁的逻辑
