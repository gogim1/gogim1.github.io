---
title: "编译器设计--优化简介"
tags: [compiler, notes]
---

Engineering a Compiler: Introduction to Optimization 

<!--more-->

编译器前端将源代码转换为某种 IR， 后端将 IR 转换为某种可以直接在目标机上执行的形式。两个过程之间就是编译器的中间部分优化器，负责转换前端产生的 IR，以提高后端生成代码的质量。

代码优化需要在编译时发现程序运行时行为的信息，并利用其来改进生成的代码。改进有多方面，除了执行效率，还有代码长度、能耗、对实时事件的响应、内存的访问量等。

有很多因素能够带来优化的机会。低效性主要来源是对源语言抽象的实现。因为源语言转换 IR 是个局部的过程，不能对上下文进行广泛分析，生成的 IR 是处理源语言结构的最一般情形。另一个重要来源在于目标机影响性能的属性，比如功能单元的数目和能力、内存层次结构中各个层次的延迟和带宽，指令集寻址方式等等，这些都会影响编译器为有特定需求的程序生成代码的方式。

早期，人们将优化看成编译器的可选特性，这带来了调试编译器和优化编译器的区别（-O0、-O3）。现代优化器假定后端会处理资源分配的问题，因此优化器通常是对具有无限寄存器、内存和功能单元的理想机器进行优化。

举个计算数组地址的例子。考虑前端对 Fortran 数组引用 m(i, j) *先列后行*生成的 IR。如果不了解 m、i、j 的具体知识或上下文，那编译器必须生成寻址二维数组的完整表达式：@m+(j-low2(m))*(high1(m)-low1(m)+1)*w+(i-low1(m))*w。@m 是第一个元素的运行地址，lowi(m) 和 highi(m) 是 m 第 i 个维度的下界和上界（即以 0 起始？维度大小？），w 是一个元素的长度。

如果 m 是局部变量，各维度下界为 1 且上界已知，则编译器可将计算数组地址的表达式简化为@m+(j-1)*high1(m)*w+(i-1)*w。

如果数组引用出现在循环内，且在循环中 j 从 1 变动到 k，则可以利用运算符强度削减（Operator Strength Reduction）进行进一步优化。即 (j-1)*high1(m)*w 将替换为序列 j1' j2' j3' ...，ji'=ji-1'+high1(m)*w。
如果 i 也是个循环的归纳变量，也可同理进行优化。

如果 m 是过程实参，那么编译器可能无法在编译时获取相关知识，因为在过程的不同调用中，m 的上下界可能是变化的，因此无法像上文一样简化地址计算。

接下来举 LINPACK 库中循环嵌套的一个例子，库作者做了对外层循环进行展开，把多个赋值合并为一条语句。理想情况下，编译器会自动将原本循环嵌套的代码变换为循环展开或其他更适合目标机的形式。但很少有编译器包括了完成该目标的所有优化。

对于循环展开的版本，从编译器角度来看，语句中包含很多不同的数组地址的计算，应该简化这些计算。比如对于地址计算中内层循环的不变量，可以保持在寄存器中。 如果目标机有等价于 loadAI （使用寄存器基地址和常数偏移量寻址）的指令，那么可以对地址引用进行重构，使用相同的基地址与不同的常数偏移量进行表示。

如果编译器不能执行上述优化，那么循环展开的版本可能生成更差的代码。比如如果无法重构地址表达式，那么需要维护多个归纳变量，迫使寄存器分配器在循环中插入额外的 load 和 store 指令。

每种优化都需要保证安全性和可获利性，既能保持原有语义，又能提高程序性能。比如刚刚的循环展开例子，减少了循环控制的开销，循环中执行一次内存操作能够执行更多工作，受限于内存的可能性较小。在一个循环中，如果 load/store 指令耗费的周期数多于计算指令的耗费，则认为该循环是受限于内存的。

循环展开也能帮助编译器做其他优化，展开会增加内层循环代码的数量，为指令调度器提供隐藏延迟的机会。如果循环末尾的分支指令延迟很长，则较长的循环体使编译器能够填充分支延迟槽中更多的部分。在一些处理器上，不使用的延迟槽会用 nop 填充，循环展开可以减少处理器取到的 nop 指令数目。

总结一下，可供优化编译器利用的时机有几种不同的来源：

1. 减少抽象的开销。程序语言引入的数据结构和类型需要运行时支持，优化器可以通过分析和变换来减少开销，如计算数组地址的例子
2. 利用特例。比如编译器通过上下文的知识可以确定对于 C++ 某个虚函数的调用总是使用同一个实例，那么可以重新映射该调用
3. 将代码匹配到系统资源。如果程序的资源需求与处理器能力不服，那编译器需要对代码进行变换

刚刚的例子是对单一数组引用以及循环嵌套的优化，然而优化还可以在更大的范围上，不同的粒度上进行，比如局部的、区域性的、全局的、整个程序。

局部优化作用于单个基本块。基本块保证语句顺序执行、除非运行时异常否则任一语句执行整个基本块也执行。因此编译器能够利用这两个性质来证明更强的事实，做出在更大范围上无法达到的优化。

区域性的作用范围大于单个基本块小于一个完整的过程。与整个过程相比，区域性有时能够进行更好的优化。比如循环嵌套内部，编译器能够证明一个大量使用的指针是常量，尽管该指针在过程中的其他位置会被修改。因此在该区域中的指针引用的值可以保持在寄存器中。

全局方法又称为过程内方法，作用在整个过程上。因为局部最优的优化在更大的上下文中可能不是最优。

过程间方法考虑的范围大于单个过程，也带来新的挑战。过程间优化两个经典例子是内联替换（inline substitution）和过程间常数传递（interprocedural constant propagation）。

随着优化范围加大，优化时机也更多，但分析较大范围代码得到的知识通常不怎么精确，因此优化范围与生成代码质量并不存在一个简单的关系。

### 局部优化
本节介绍两种局部优化方法：值编号（value numbering）和树高平衡（tree-height balancing）。值编号用于重用计算过的值来替代冗余表达式，树高平衡用于重新组织表达式以带来指令层次的并行性。

**局部值编号** 考虑下面的基本块，第四条语句是冗余的。
```
a = b + c
b = a - d
c = b + c
d = a - d
```
我们可以把第四条语句替换为 d = b。或者可以把后续代码使用 d 的地方都替换成 b，但这种方法需要确定在每一处 d 的位置上 b 是否被修改。一个简单的解决方法是，在使用前插入复制操作，由后续的一趟 pass 来判断复制操作是否必须，是否可以合并。

将冗余替换为之前计算的值并不总是可获利的。比如上面的例子，替换成 d = b 可能会延长 b 或缩短 a 和 d 的生命周期，导致影响到对寄存器的需求。然而代码到达寄存器分配器前还会有很多变换，因此优化器无法预测寄存器分配器的行为，于是总是假定删除冗余是可获利的。

刚刚的例子中，冗余表达式的文本是相同的。再看下面的例子，冗余表达式的文本是不同的。
```
a = b * c
d = b
e = d * c
```

因此依赖于文本相同的技术在这里不可行，必须跟踪值通过名字发生的流动。

现有包含 n 个 T = L Op R 表达式的基本块，基本的局部值编号（Local Value Numbering, LVN）算法会维护一个哈希表，并按顺序处理基本块中每个表达式。对于第 i 个操作，从表中获取 L 和 R 的值编号，然后基于两者的编号和 Op 一起构造 T 的哈希键，接着在表中查找该键。如果找不到则在表中插入哈希键和新的值编号对，并将新的值编号赋予 T。 则说明该表达式是冗余的，可以替换为查找到的值编号，同时也要把该值编号赋予 T。

注意这里不是根据文本计算出哈希值，而是根据编号。因此不同变量具有同个编号（即值相同）就可以得到同个哈希值。

表达式的顺序对于分析冗余的结构有直接的影响。考虑 v = a * b * c 和 v = a * (b * c) ，如果 b * c 在上下文出现过，则右边表达式将产生冗余而左边不会。如何重排表达式以提高优化的效果，通常从采用启发式技术，因为重排表达式的方法太多了。

一些优化的点：

* 对于顺序不同的运算对象，如 a * b 和 b * a 应该分配一样的值编号。这里可以采用一些方案，比如按照值编号大小，来对运算对象排序，确保计算出同样的值编号
* 常量合并。可以在哈希表中存放有关常数的信息，如果运算对象都是参数，则可以将表达式替换为立即数加载操作
* 代数恒等式。比如 x+0 和 x 应该分配同样的编号，这需要为每种恒等式进行条件判断，可能造成性能问题。LVN 应该将这些条件判断组织到特定于运算符的决策树中。？

考虑下面的例子，如果尝试运用刚刚的 LVN 算法，会有一些问题。
```
a = x + y
b = x + y
a = 17
c = x + y
```
在第四个表达式中，无法将表达式重写为 c=a，因为 a 的值编号已经变了。有两个方法来解决这个问题：

1. 维护一个值编号到名字列表的映射。替换时可以选择对应列表中的任何名字
2. 为每个赋值操作赋予不同的名字，比如为每个名字添加递增下标来保持唯一性，这样每个名字有且只有一个定义

前面的讨论都基于直接的赋值，但是对于间接赋值，如指针、结构体或数组赋值的情况，会导致编译器对值流动的推测出错，是值编号及其他优化变复杂。考虑刚刚下标命名方案的值编号算法，当 *p = 0 时，编译器不知道 p 可能指向的内存位置，不知道应该递增哪个变量的下标，因此只能对所有可能被修改的变量下标。再比如 a(i, j) = 0，如果 i 或 j 时未知的，那只能假定赋值操作改变了 a 中所有元素。

**树高平衡** 现代处理器有多个功能单元，可以在每个周期执行多个独立的操作。如果编译器可以通过编排指令流使之包含独立的多个操作，那么程序会运行得更快。考虑表达式 a+b+c+d+e+f+g+h，如果处理器每次可以执行多个加法，那么可以按照 ((a+b)+(c+d))+((e+f)+(g+h)) 顺序来编码指令。

树高平衡算法分为两部分：分析和变换。分析用于确定基本块中的候选表达式树有哪些。候选树中，所有的运算符相同且可交换和可结合的，而且内部节点的名字都只使用一次。变换类似于构建哈夫曼树，会从存放子树的优先队列中，依次取出权重最小的两个进行合并再放回，直至生成最终的平衡树。

基本块中的展现值（exposed value）指的是在基本块后被使用，或者在基本块中被使用超过一次的值。如何获得基本块中的展现值，可以通过计算 LiveOut 集合获得。

分析阶段会遍历基本块中的表达式。比如分析到 T = L Op R，会判断 T 是否展现值。如果是展现值，则将 T 及 Op 的运算优先级一起加入到以 Op 运算优先级为权重的队列中，作为候选表达式树的根节点。

比如现有基本块如下，这里的展现值有 t3, t6, t7, t10, t11
```
t1 = 13 + s
t2 = t1 + t
t3 = t2 + 4
t4 = t3 * u
t5 = 3 * t4
t6 = v * t5
t7 = w + x
t8 = t7 + y
t9 = t8 + z
t10 = t3 * t7
t11 = t3 + t9
```
分析阶段得到的优先队列包含 (t11,1), (t7,1), (t3,1), (t10,2), (t6,2)。

变换阶段会遍历分析阶段得到的优先队列。对于每个队列元素，即候选表达式树的根节点，会维护另一个以操作数为权重的优先队列。递归候选表达式树，获得每个操作数并为之赋予权重加入队列中。如果该操作数是常数，则权重为 0；操作数是叶子节点，权重为 1；操作数是另一候选表达式树的根节点，则递归获得权重；否则是中间节点，则权重为左右子树权重之和。

如上面的例子中，首先会对优先队列中 t11 进行变换，获得操作数及其权重，(z,1),(y,1),(t7,2),(t3,2)。这里 t7，t3 的权重会通过递归，变换获得。

候选表达式树获得的操作数及其权重，就会按照类似于构建哈夫曼树进行重建。例子中，t11 候选表达式树就会变成：
```
n1 = z + y
n2 = n1 + t7
t11 = n2 + t3
```

例子中最终生成的代码如下：
```
n0 = 17 + t
t3 = n0 + s
t7 = x + w
n1 = z + y
n2 = n1 + t7
t11 = n2 + t3
t10 = t7 * t3
n3 = 3 * v
n4 = n3 * u
t6 = n4 * t3
```

可以看到，在变换阶段也能实现像 LVN 的常量折叠的效果。

### 区域优化
本节介绍两种作用于多个基本块的优化技术。从局部优化到区域优化，主要的复杂之处在于处理控制流的不同路径。

**超局部值编号** Superlocal Value Numbering，SVN。思路在于将多个基本块当成一个基本块，当成直线式代码进行局部值编号。这要求除了第一个基本块，其他基本块都不能有多个前趋。

难点在于如何高效地处理，因为处理多条包含同个基本块的路径，都会重复分析该基本块。因此我们需要重用分析过的结果，这里有三种方式：

* 记录每个基本块在边界处的状态，必要时恢复
* 逆向遍历基本块，撤销某个基本块造成的影响
* 使用包含哈希表的链表。进入基本块时创建哈希表，追加到链表。撤销时删除链表最后一个元素

第三种比较简单和快速，因为能重用编译器前端实现作用域的代码。不过有一些问题，名字的值编号是记录在定义该名字基本块的哈希表中，而后续基本块为该名字计算的新值编号也记录在原本哈希表中，撤销后续基本块的哈希表会导致新值编号仍然存在。

为避免这种情况，可以在只定义名字一次的表示法，比如 SSA，上运行 SVN 算法。

**循环展开** 减少控制流的分支数，循环体内部产生重用，减少内存访问。但也有一些缺点，比如增大程序的长度，增大编译时间，可能会撑爆指令高速缓存。

循环展开也有一些间接的影响，比如

* 增加循环体中独立操作的数目，方便指令调度器让多个指令同时运行
* 将连续的内存访问移动到同一迭代中，提高内存访问局部性，利用多字操作进行内存访问
* 暴露跨迭代的冗余
* 增加变量在循环中的出现的次数，可能改变寄存器分配器的决策
* 循环展开可能对寄存器有了更大的需求，额外的寄存器逐出可能会超过循环展开带来的效益

要预测这些间接影响很困难，一般使用自适应方法，由展开因子来确定。

### 全局优化
作用于整个过程上。由于作用域包括有环的控制流，所以通常会先进行一个分析阶段。本节介绍两个例子。

**利用活动信息查找未初始化变量** 严格来说这不是优化。它使用全局数据流分析技术来揭示过程中值流动的信息。对于其他优化都有帮助。

如果过程 p 在为变量 v 分配值之前就使用了 v 的值，则 v 在被使用时是未初始化的。通过计算活动情况的信息，我们可以找到这些未初始化变量。

CFG 中存在一条从 p 到使用 v 的某个位置之间的路径，且 v 在该路径中没有被重新定义，则 v 在 p 处是活动的。我们把每个基本块的活跃变量记录到集合 LiveOut 中，LiveOut(b) 包含基本块 b 退出时所有的活跃变量。也就是说，集合中变量的值在后续基本块会被用到。

计算 LiveOut 集合的公式如下，其中 UEVar(m) 包含在 m 中重新定义前就被使用的变量，VarKill(m) 包含 m 中定义的变量。

$LiveOut(n) = \cup(UEVar(m) \cup (LiveOut(m)-VarKill(m))),m \in succ(n)$ 

可以看出，这是一个反向数据流的问题，我们可以通过迭代不动点的方式来为每个基本块计算出 LiveOut。

当计算出 LiveOut 集合，查找可能的未初始化变量就简单了。如果 n 是 CFG 的入口结点，则 LiveOut(n) 中的值都可能会是未初始化。

识别未初始化变量可能会出错：

* 如果 v 可通过另一个名字被访问并初始化，比如使用指针指向 v，那么分析可能识别不出 v 与指针的关联
* 如果 v 在过程调用前就被初始化，比如是静态变量或者当前作用域之外的变量，那可能会误以为是未初始化变量
* 如果使用了未初始化变量的路径在运行时是不可能出现的，但 v 仍然出现在 LiveOut 集合中

如果分析的过程又调用另一个过程，而在缺少被调用者信息的情况下，只能假定每个可能被修改的变量会被修改，每个可能被使用的变量会被使用。

活跃变量的信息可以在很多优化中被使用，除了之前说的树高平衡，还有寄存器分配（除非值是活跃的，否则不必保持在寄存器中）、SSA 的构建（基本块中的不活跃的值，不需要插入 phi 节点？）、发现无用的 store 操作（如果值是不活跃的，则不需要存储到内存）

**全局代码置放** 许多处理器的分支指令代价不对称，比如落空分支（控制流直接往下走）比采纳分支（控制流需要跳跃到该分支）更快。因此需要移动代码，让执行频度更高的分支控制流走落空分支。

代码置放具有独立的分析和变换阶段。分析阶段收集分支执行频度数据，变换阶段利用这些数据来对基本块进行排序。

收集剖析信息有几种方式：

* 编译器往生成的代码中插入统计信息
* 定时器以较高的频率中断程序的执行，统计中断时程序计数器 pc 的位置
* 如果处理器提供硬件计数器来统计事件，如处理器周期数，缓存失效或采纳分支，则可直接使用

编译器应该统计 CFG 各条边的执行次数，而不是基本块的执行次数。如下图，左边能够判断出 (B1,B3) 作为落空分支会更好。而如果按照右边基本块执行次数的方式统计，则 B3 和 B4 会具有同等重要性。

```
       B0                   B0 10
       │ │                  │ │
   7┌──┘ └─┐3            ┌──┘ └─┐
    │      │             │      │
    ▼      ▼             ▼      ▼
   B1     B2          7 B1     B2 3
  │ │      │           │ │      │
5┌┘ └──┐ ┌─┘          ┌┘ └──┐ ┌─┘
 │   2 │ │3           │     │ │
 ▼     ▼ ▼            ▼     ▼ ▼
B3     B4          5 B3     B4 5
 │     │              │     │
5└─┐ ┌─┘5             └─┐ ┌─┘
   ▼ ▼                  ▼ ▼
    B5                   B5 10
 10 │                    │
    ▼                    ▼
```

得到每条边的执行次数后，就需要构建出执行最频繁的路径，即热路径。这里使用贪婪算法，按照执行频度从高到低的顺序选择边 &lt;x, y&gt;，如果有以 x 为结尾块、以 y 为起始块的两条路径，则会合并为新路径，新路径的优先级取两条路径的最小值。初始情况下，每条路径的优先级可以设置为一个大数 E，当合并两条初始的路径，优先级为已经合并的数目。

刚刚的例子计算的热路径如下：

| 选择的边 | 路径集合 | 已经合并的数目
| - |  - | -
| - | (B0)E, (B1)E, (B2)E, (B3)E, (B4)E, (B5)E | 0
| (B0,B1) | (B0,B1)0, (B2)E, (B3)E, (B4)E, (B5)E | 1
| (B3,B5) | (B0,B1)0, (B2)E, (B3,B5)1, (B4)E | 2
| (B4,B5) | (B0,B1)0, (B2)E, (B3,B5)1, (B4)E | 2
| (B1,B3) | (B0,B1,B3,B5)0, (B2)E, (B4)E | 3
| (B0,B2) | (B0,B1,B3,B5)0, (B2)E, (B4)E | 3
| (B2,B4) | (B0,B1,B3,B5)0, (B2,B4)3 | 4
| (B1,B4) | (B0,B1,B3,B5)0, (B2,B4)3 | 4

计算出热路径后，就进行代码布局。取出第一条热路径放入 WorkList，把路径中的基本块顺序放置。同时与该路径中基本块相关的路径也加入 WorkList。按照优先级从小到大的顺序取出另一条热路径放置代码，直至 WorkList 为空。于是例子中放置的结果为 (B0,B1,B3,B5,B2,B4)

### 过程间优化
过程调用对于编译器生成高效代码有利有弊。从正面看，限制编译器需要考虑的代码数量。从负面来看，限制了编译器理解调用过程内部行为的能力，引入了调用者调用前返回后的代码、被调用者起始收尾代码的开销。

为支持过程间分析，编译器的结构也需要改变。因为对于传统的编译器来说，编译单元生成的代码只取决于该内容，一旦要支持过程间分析，生成的代码就需要同时取决于多个编译单元。这也带来一些依赖性，对某个编译单元的修改可能导致需要重新编译其他单元。

为让编译器能够访问其需要的所有代码，提出了几种编译器结构：

* 扩大编译单元。这种方式最简单，但也会限制过程间优化的机会，促使程序员创建较大的编译单元
* 集成开发环境。在源代码发生改变时，IDE 可以通知编译器，由编译器确定是否需要重新编译
* 将过程间优化转移到链接器。但这种方案的优化结果没有传递到编译器，因此需要在链接器执行后续的全局优化

接下来介绍两种不同的过程间优化技术

**内联替换** 为实现过程调用会有很多额外的操作：分配活动记录、实参求值、保存调用者状态、创建被调用者环境、控制转移、返回值传递。编译器可以通过内联替换减少这些开销。

内敛替换有两个问题，变换和决策需要变换的过程。

变换相对简单，但仍有一些注意的点。一些源语言结构可能导致内联的代码控制流很复杂，比如多个过早的返回语句，或者 Fortran 的交替返回（alternate return）特性，都会使控制流图变得复杂。

除此之外，也要注意内联后局部变量变多的问题。考虑内联过程的一个简单实现，在被调用点处为过程的局部变量创建对应的局部变量。这时如果内联多个过程，或者在几个调用位置内联同一个过程，会有局部变量太多的问题。这不是一个正确性问题，但会影响其他的优化过程。其实这里我们只要能够做到重用局部变量就可以了。

决策过程比较复杂且对性能有直接影响。内联过程不一定都会提高性能，比如会增加代码长度和命名空间规模，影响到寄存器的需求。因此有多个方面来考虑是否需要内联替换：

* 体系结构特点。比如说是否有更大的寄存器集合
* 被调用者规模。被调用者代码长度是否小于过程链接代码（调用前代码序列、返回后代码序列、起始代码序列和收尾代码序列）
* 调用者规模。编译器可能会限制过程的总长度，来避免编译时间增加和降低优化性能
* 调用次数。对频繁执行的调用进行内联替换会有更大的收益
* 常数值实参。调用位置的实参如果已知是常数，那么内联能带来常数折叠的优化空间
* 被调用的位置数。如果过程只在一个地方被调用，那么内联不会带来代码长度的增加。注意编译器应该在内联后更新这些位置数据，以发现由于内联的进行而减少到只剩一个调用位置的那些过程
* 被调用者是否调用其他过程。通常叶过程是良好的内联候选者
* 调用点是否在循环内。循环内的过程执行会比较频繁，也难以把整个循环当作基本块进行优化

一般编译器会采用启发式决策来决定是否内联替换

**过程置放** 思想很简单，当过程 p 调用 q，我们希望 p 和 q 占用相邻的内存位置，才能更好地利用局部性。同样，这个算法也类似于上面见过的全局代码置放，由分析和变换两个阶段组成。

分析阶段统计出每条调用边的频度。变换阶段按照频度从高到低的顺序依次取出边 &lt;x, y&gt;，把过程 y 的代码放置 x 之后，合并 x 和 y 为一个节点。合并可能需要修改与 x 和 y 相关的其他边的指向及边的频度。当每条调用边都处理完，调用图就已经被合并为一个节点，所有过程的置放顺序也就确定了。

