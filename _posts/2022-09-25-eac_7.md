---
title: "编译器设计--代码形式"
tags: [compiler, notes]
---

Engineering a Compiler: Code Shape

<!--more-->

本章关注实现源语言中各种结构的方法，这些实现的具体细节会影响到编译器在后续各趟处理中分析和改进代码的能力。不同的实现方法使用的内存、寄存器、耗能各异，这些区别源于代码形式的不同。

比如所要实现条件位单字节字符值的 switch 语句，可以用一系列的 if 判断来实现，这将退化为线性查找。也可以用二分查找，这会快不少。如果要利用空间换时间，则可以构建一个哈希表，这样查找的时间是常数级的。对于特定的 switch 语句来说，判断使用哪种方法取决很多因素，最重要的是 case 的数目和相应的执行频度。

考虑另一个例子 x + y + z，源代码可以映射为求值顺序不同的一系列二元加法操作。编译器需要知道表达式的上下文，才能选择最佳的求值顺序。

### 分配存储位置
编译器必须为代码中产生的值分配存储位置，因此必须了解该值的类型、长度、可见性和生命周期。除此之外，还要考虑内存的运行时布局、源语言对数据区和数据结构布局的约束、目标处理器对数据位置或使用的约束。

编译选项也可能影响到值的放置。比如调试需要保留所有调试器可以引用的名字。

编译器会使用两种常见的内存模型来确定将值保持在寄存器还是内存中，分别是内存到内存模型和寄存器到寄存器模型。内存到内存模型假定值都在内存中，按需加载到寄存器，定义后写回内存。IR 通常使用物理寄存器名，编译器确保对寄存器的需求不会超出实际寄存器。？寄存器到寄存器模型假定有足够的寄存器，仅在必要时将虚拟寄存器的值写回内存。

内存模型的选择会影响到编译器的结构，比如内存到内存模型中，寄存器分配器是一种可选优化。而寄存器到寄存器模型中，寄存器分配器是必须的。

程序地址空间布局、操控和管理的许多决策超出编译器的范围，与操作系统和处理器相关。最常见的一种程序地址空间布局，从低地址到高地址分别是：代码、静态或全局数据、堆、空闲内存、栈。

为方便起见，编译器会把同样生命周期和可见性的值都放在一个位置，由此划分不同的数据区。比如过程局部变量放置在过程活动记录内部，过程静态局部变量放在内存中的静态区域。

对于每个数据区，编译器必须计算出一个布局，为其中的变量分配偏移值。目标机的 ISA 可能会限制这些偏移值，要求遵守对齐规则。

对于代码中使用位置接近的两个值，编译器最好能够把两者都加载到高速缓存中。最佳情况下是两者在同一缓存块中。如果不能，则可以通过控制变量地址的距离来让两者映射到不同缓存行。？逻辑地址到物理地址的映射不一定会保持特定变量之间的距离。因此编译器对于不同内存页上两个变量的布局几乎是不起作用，应该专注于让同时被引用的对象放置在同一内存页。

寄存器到寄存器模型中，编译器只保持无歧义的值，直到定义另一个有歧义的赋值。除非能证明两个值指向的地址集合不相交。比如 C 语言中，局部变量只要没有被获取过地址，那它就都是无歧义的。？更复杂的分析需要对每个指针建立潜在名字的集合，如果集合只有一个元素，则无歧义。

语言特性会影响到编译器分析歧义的能力，比如 C 语言的 restrict 关键字可以通知编译器某个指针是无歧义的，volatile 关键字可以通知某个变量可能发生改变。

### 算术运算符
许多问题都会影响到代码生成的质量。比如数据存储位置不同，生成的加载指令数目也不同，使用的寄存器数目也不同。即使存储位置相同，不同的代码形式也会影响到对寄存器的需求。

比如 a - b * c。假设数据都在内存中，且按照树后序遍历的方式生成代码。从左到右遍历和从右到左遍历生成的代码经过寄存器分配器优化后，所需的寄存器数目不同。

在生成代码的阶段，以上面的例子，我们生成的加载指令是
```
loadI @a        -> r1
loadA0 rarp, r1 -> r2
```
而非 `loadAI rarp, @a -> r2`，这有几个原因：

1. 针对 @a 给出了显式名字，如果在上下文需要 @a，则可以重用
2. 偏移量 @a 可能无法转入 loadAI 的立即数字段

在优化阶段，编译器可能通过发现的知识将两条指令合并为单个指令。但更好的做法是将该问题推迟到指令选择器，将第二个原因中与机器相关的因素隔离到编译器处理机器相关的阶段。

为了选择一种能够减少寄存器使用量的求值顺序，必须不断交换左右子树并计算可能的改进。一般来说，只要对每个节点中使用寄存器数最大的子树先求值，就能最小化寄存器的使用。因此要求对代码进行两趟处理，先计算寄存器使用量，然后输出处理后的代码。

重排表达式可以暴露出一些额外的优化机会。但是由于精度的限制，浮点数表达式不应该重排，除非语言定义允许这么做。

函数调用的存在，可能会限制编译器改变表达式顺序的能力，因为函数可能有副作用，可能修改其他变量的值。这促进过程间分析的大部分工作。

### 布尔表达式和关系运算符
布尔值有两种表达方式：数值编码和位置编码。前者为 true 和 false 分配具体的数值。后者通过代码不同分支控制流来表示求值结果。如果布尔表达式的结果不需要存储，则使用位置编码是有意义的，否则选择数值编码方案。

目标机指令集的具体细节会影响到关系运算的实现方式，其中有几种方案：直接条件码、条件复制、布尔值比较和谓词操作。

直接条件码中比较操作会设置一个条件码寄存器，只有条件分支操作能够读取寄存器的值。优势在于一些处理器能够通过算术运算来设置条件码，这样可以避免比较操作。？

条件复制方案为模型增加一个条件复制的指令，这样可以避免比较操作和分支，但是会对指令中的两个表达式都求值。对于要求短路求值的语言，这可能带来风险。

布尔值比较和直接条件码类似，不过它对关系运算求值可以无需分支操作。缺点在于总是需要显式的比较操作。

谓词执行模型中，目标机可以在指令前加一个谓词表达式来决定指令是否生效。这种方案生成的代码精炼，但在一些场合下，不如其他采用分支的方案，这在后面小节会谈及到。

### 数组的存储和访问
本节介绍几种在内存中布置数组的方案。

考虑引用一维数组的元素，如果我们使用基地址加偏移量的寻址方式，以及使用零作为索引下界，那么可以简化代码。如果编译器不知道数组的上下界，那么可以在运行时计算数组的虚零点。像 C 语言则采用另一种策略，强制使用 0 作为数组下界。

多维数组有几种实现方式：行主序、列主序和间接向量。间接向量像拉链法的哈希表，优点在于容易实现不规则数组。

数组作为参数传递时，通常采用引用的方式。编译器需要在被调用者中将引用绑定到对应的形参，因此需要数组引用的各维度信息。Fortran 中要求程序员在声明数组时指定维度。其他的一些语言则时会收集必要的信息留给编译器处理。比如编译器会建立一个描述数组信息的消息矢量（dope vector），在被调用过程的 AR 中为该数据结构分配空间，而实参传递的值时指向该数据结构的指针。

访问检查最简单的实现就是在数组引用前都加一个条件判断，则可能需要在信息矢量中加入额外的信息。这种方式开销可能很大，也有一些技术可以降低范围检查的开销。也有一些其他的实现方式，比如让编译器证明给定的引用不会产生越界访问。

### 字符串
必须为字符串选择一种表示，所选方法对字符串操作的性能有巨大影响。考虑两种方式，一种是 C 语言的以 \0 结尾的方式，另一种是长度+数据的方式。当对字符串执行操作，比如查询长度，这两种方式的性能就不同。

### 结构引用
编译器必须直到结构体的起始地址和每个结构成员的长度及偏移，可以通过建立一个表来保存这些结构布局的信息。布局必须遵守目标体系结构的对齐规则，如果源语言不允许用户定义结构布局，则编译器可以按任意顺序布局，以缩小结构空间占用。

对于联合这种结构，有几种实现方案。比如源语言强制程序员使用无歧义的引用。另一种方案是，联合中有个字段 tag 用于区别不同变体，由运行时进行标记和判断。

### 控制流结构
在条件执行语句中，随着 then 和 else 代码的增长，内部代码高效执行的重要性开始超过控制表达式执行的代价。假设 then 和 else 都包含 10 条独立的操作，在双发射机器上，支持谓词执行的方式会使每个 false 的操作都占用一个发射槽，这导致每个分支都需要 10 个周期。而不使用谓词方式，采取分支跳跃则能使每个分支都只需要 5 个周期。

因此实现条件判断语句方案中，选择分支还是谓词需要考虑：

1. 如果一条分支执行频度显著高于另一条，那更需要加速该路径，这倾向于使用分支方案
2. 如果一条分支的代码数比另一条多得多，则也不适合使用谓词执行
3. 每个分支都包含复杂的控制流，比如嵌套 if，那么使用谓词执行会很糟糕

循环结构都有一个相似的结构，也有一些优化的地方。比如可以使用循环体中的指令来填充延迟槽、常量折叠以消除部分分支甚至循环本身。

许多程序语言都有包含 case 语句的变体，比如 Fortran 的 goto，C 语言的 switch。case 语句的复杂点在于，如何高效定位目标 case 子句。有三种策略：线性查找，二分查找和直接计算地址。

### 过程调用
